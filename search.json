[{"title":"3D Gaussian Splatting 学习笔记","path":"//posts/2024/11/blog-post-1/","content":"三维高斯分布一维高斯分布 $x\\sim{}\\mathcal{N}(\\mu,\\sigma^2)$ 的概率密度函数：f(x)=\\frac{1}{\\sigma\\sqrt{2\\pi}}\\text{exp}(-\\frac{(x-\\mu)^2}{2 \\sigma^2})三维独立高斯分布的概率密度函数为： \\begin{align} f(\\mathbf{x}) &=f(x_1,x_2,x_3) \\\\ &=f_1(x_1)f_2(x_2)f_3(x_3) \\\\ &=\\frac{1}{(2\\pi)^{\\frac{3}{2}}\\sigma_1\\sigma_2\\sigma_3} \\text{exp}(-\\frac{(x_1-\\mu_1)^2}{2 \\sigma_1^2}-\\frac{(x_2-\\mu_2)^2}{2 \\sigma_2^2}-\\frac{(x_3-\\mu_1)^2}{2 \\sigma_1^2}) \\end{align}其中，$\\mathbf{x}=(x_1,x_2,x_3)^\\top$，将二次型形式转换为矩阵表达， \\begin{align} &-\\frac{(x_1-\\mu_1)^2}{2 \\sigma_1^2}-\\frac{(x_2-\\mu_2)^2}{2 \\sigma_2^2}-\\frac{(x_3-\\mu_1)^2}{2 \\sigma_1^2}\\\\ &= \\begin{bmatrix} x_1-\\mu_1, x_2-\\mu_2, x_3-\\mu_3 \\end{bmatrix} \\begin{bmatrix} &\\frac{1}{\\sigma_1^2},&0,&0\\\\ &0, &\\frac{1}{\\sigma_2^2},&0\\\\ &0,&0,&\\frac{1}{\\sigma_3^2} \\end{bmatrix} \\begin{bmatrix} x_1-\\mu_1 \\\\ x_2-\\mu_2 \\\\ x_3-\\mu_3 \\end{bmatrix}\\\\ &=-\\frac{1}{2}(\\mathbf{x}-\\mathbf{\\mu})^{\\top}\\Sigma^{-1}(\\mathbf{x}-\\mathbf{\\mu}) \\end{align}其中，三个变量$\\mathbf{x}=(x_1,x_2,x_3)^\\top$之间都是相互独立的，所以变量之间的协方差是对角阵的形式，即 \\Sigma= \\begin{bmatrix} &\\sigma_1^2,&0,&0\\\\ &0, &\\sigma_2^2,&0\\\\ &0,&0,&\\sigma_3^2 \\end{bmatrix}也就是，$\\sigma_1\\sigma_2\\sigma_3=\\lvert\\Sigma\\rvert^\\frac{1}{2}$。因此，用向量形式表达的三维高斯分布的概率函数为， f(\\mathbf{x})=\\frac{1}{(2\\pi)^{\\frac{3}{2}} \\lvert\\Sigma\\rvert^\\frac{1}{2}} \\text{exp}\\big(-\\frac{1}{2}(\\mathbf{x}-\\mathbf{\\mu})^{\\top}\\Sigma^{-1}(\\mathbf{x}-\\mathbf{\\mu})\\big)对于更为一般的，相关多元高斯分布，我们先假设有$n$个相关的变量$\\mathbf{X}=[X_1,X_2,X_3]^\\top$，其协方差矩阵为$\\Sigma$，由协方差矩阵的性质可知，其一定为实对称矩阵，因此协方差矩阵可以正交分解，即 \\mathbf\\Sigma=\\mathbf{V}\\Lambda\\mathbf{V}^\\top=\\mathbf{V}\\Lambda\\mathbf{V}^{-1}其中，$\\mathbf V$是单位特征向量组成的矩阵，$\\Lambda=\\text{diag}(\\lambda_1,\\lambda_2,\\lambda_3)$。对相关变量应用一次变换，$\\mathbf{X’}=\\mathbf{V}^\\top\\mathbf{X}$。变换后的高斯分布的期望为$\\mathbf{\\mu’}=\\mathbf{V}^\\top\\mathbf{\\mu}$。 \\begin{align} \\Lambda &= (\\mathbf{V}^{-1}\\mathbf{V})\\Lambda(\\mathbf{V}^{-1}\\mathbf{V})\\\\ &=(\\mathbf{V}^{\\top}\\mathbf{V})\\Lambda(\\mathbf{V}^{\\top}\\mathbf{V}) \\end{align}变换后高斯分布的协方差矩阵为， \\begin{align} \\mathbb{E}\\big((\\mathbf{X'}-\\mathbf{\\mu'})(\\mathbf{X'}-\\mathbf{\\mu'})^\\top\\big) &=\\mathbb{E}\\Big(\\mathbf{V}^\\top(\\mathbf{X}-\\mu)\\big(\\mathbf{V}^\\top(\\mathbf{X}-\\mu)\\big)^\\top\\Big) \\\\ &=\\mathbb{E}\\Big(\\mathbf{V}^\\top(\\mathbf{X}-\\mu)(\\mathbf{X}-\\mu)^\\top \\mathbf{V} \\Big) \\\\ &=\\mathbf{V}^\\top\\mathbb{E}\\Big((\\mathbf{X}-\\mu)(\\mathbf{X}-\\mu)^\\top\\Big)\\mathbf{V} \\\\ &= \\mathbf{V}^\\top\\mathbf{\\Sigma}\\mathbf{V} \\\\ &= \\mathbf{\\Lambda} \\end{align}由于$\\mathbf{\\Lambda}$是对角阵，所以高斯分布各分量之间不相关；又因为多元高斯分布不相关和相互独立等价，因此变换后的$\\mathbf{X’}$变量之间是相互独立的。 三维高斯溅射论文中对三维高斯分布做了简化处理，和标准形式对比可以看到去掉了指数部分前面的尺度系数，默认模型坐标中心在原点，方便旋转放缩。 G(\\mathbf{x})=e^{-\\frac{1}{2}(\\mathbf{x})^\\top\\Sigma^{-1}\\mathbf{x}}其中，$\\mathbf{x}=[a,b,c]^\\top$是三维列坐标，$\\mu$是椭球中心，协方差矩阵$\\Sigma$为： \\Sigma = \\begin{bmatrix} &\\sigma_a^2 &\\text{Cov}(a,b) &\\text{Cov}(a,c)\\\\ &\\text{Cov}(a,b) &\\sigma_b^2 &\\text{Cov}(b,c)\\\\ &\\text{Cov}(a,c) &\\text{Cov}(b,c) &\\sigma_c^2\\\\ \\end{bmatrix}协方差矩阵控制椭球在3轴向的伸缩和旋转，其中协方差矩阵的特征向量就是椭球对称轴。且根据协方差矩阵的性质，$\\Sigma$半正定。因此为了避免带约束条件的优化，将协方差矩阵看作一个椭球，而一个椭球是可以通过将球按轴向放缩在旋转得到。因此， \\mathbf\\Sigma=\\mathbf{R}\\mathbf{S}\\mathbf{S}^\\top\\mathbf{R}^\\top因为旋转矩阵也需要满足正定的条件，因此论文中使用四元数来表示旋转。 三维高斯溅射（世界系 $\\rightarrow$ 相机系 $\\rightarrow$ 图像平面）将三维高斯从世界系转到相机系，需要一个旋转$\\mathbf{W}$和平移$\\mathbf{t}$，由于平移不改变高斯的形状，所以 \\begin{align} G(\\mathbf{x})&=e^{-\\frac{1}{2}(\\mathbf{x})^\\top\\Sigma^{-1}\\mathbf{x}}\\\\ &=e^{-\\frac{1}{2}(\\mathbf{x})^\\top\\mathbf{W}^\\top\\mathbf{W}\\Sigma^{-1}\\mathbf{W}^\\top\\mathbf{W}\\mathbf{x}}\\\\ &=e^{-\\frac{1}{2}(\\mathbf{W}\\mathbf{x})^\\top\\mathbf{W}\\Sigma^{-1}\\mathbf{W}^\\top(\\mathbf{W}\\mathbf{x})} \\end{align}因此，相机系下三维高斯的协方差矩阵为 \\begin{align} \\Sigma_c^{-1} &=\\mathbf{W}\\Sigma^{-1}\\mathbf{W}^\\top \\\\ &=(\\mathbf{W}^\\top)^\\top\\Sigma^{-1}\\mathbf{W}^\\top \\\\ &=(\\mathbf{W}^\\top)^{-1}\\Sigma^{-1}\\mathbf{W}^{-1} \\\\ &=(\\mathbf{W}\\Sigma\\mathbf{W}^\\top)^{-1} \\end{align}即， \\Sigma_c=\\mathbf{W}\\Sigma\\mathbf{W}^\\top这样，我们就得到了相机系下三维高斯基元的分布。紧接着，我们需要将相机系下的三维高斯溅射到图像平面上的二维高斯。根据小孔成像相机模型：相机系下的三维坐标到相机平面坐标的二维坐标的映射过程为： \\begin{bmatrix} \\mathbf{X}_c\\\\ \\mathbf{Y}_c\\\\ \\mathbf{Z}_c\\\\ \\end{bmatrix} \\mapsto \\begin{bmatrix} f_x\\frac{\\mathbf{X}_c}{\\mathbf{Z}_c} \\\\ f_y\\frac{\\mathbf{Y}_c}{\\mathbf{Z}_c} \\end{bmatrix} = \\begin{bmatrix} x\\\\y \\end{bmatrix}我们将这个映射过程记为$\\mathbf{x}=\\widehat{m}(\\mathbf{X}_c)$，对这个投影变换做局部仿射近似(local affine approximation)： m(\\mathbf{X}_c) = \\widehat{m}(\\mathbf{\\mu}_c)+\\mathbf{J}_{\\mathbf{\\mu}_c}(\\mathbf{X}_c-\\mathbf{\\mu}_c)^\\top其中${\\mu}_c$是高斯中心在相机坐标系下的坐标，且 \\mathbf{J}_{\\mathbf{\\mu}_c} = \\frac{\\partial \\widehat{m}}{\\partial \\mathbf{X}_c}(\\mathbf{\\mu}_c)= \\begin{bmatrix} f_x\\frac{1}{\\mu_z} &0 &-f_x\\frac{\\mu_x}{\\mu_z^2}\\\\ 0 &f_y\\frac{1}{\\mu_z} &-f_y\\frac{\\mu_y}{\\mu_z^2} \\end{bmatrix}也就是 \\mathbf{x}\\approx \\widehat{m}(\\mathbf{\\mu}_c)+\\mathbf{J}_{\\mathbf{\\mu}_c}(\\mathbf{X}_c-\\mathbf{\\mu}_c)^\\top为了方便，我们将$\\mathbf{J}_{\\mathbf{\\mu}_c}$简记为$\\mathbf{J}$。因此，图像平面上二维高斯的协方差为： \\underset{2 \\times 2}{\\Sigma'} = \\underset{2 \\times 3}{J} \\hspace{0.5em} \\underset{3 \\times 3}{\\Sigma_c} \\hspace{0.5em}\\underset{3 \\times 2}{J}^\\top = \\underset{2 \\times 3}{J} \\hspace{0.5em} \\underset{3 \\times 3}{W} \\hspace{0.5em} \\underset{3 \\times 3}{\\Sigma} \\hspace{0.5em} \\underset{3 \\times 3}{W}^\\top \\underset{3 \\times 2}{J}^\\top最后，被投影的二维高斯被定义为： G_i'(\\mathbf{x})=e^{-\\frac{1}{2}(\\mathbf{x}-\\mathbf{\\mu}'_i)^\\top\\Sigma'^{-1}_i(\\mathbf{x}-\\mathbf{\\mu}'_i)}雅可比矩阵对应3DGS中的代码是：1234glm::mat3 J =\tglm::mat3(focal_x / t.z, 0.0f, -(focal_x * t.x) / (t.z * t.z), 0.0f, focal_y / t.z, -(focal_y * t.y) / (t.z * t.z), 0, 0, 0); 3DGS为什么要分tile？"},{"title":"CMake笔记","path":"//posts/2023/08/blog-post-3/","content":"程序代码是由头文件和源文件组成。 带有main函数的源文件编译成可执行程序，其它的编译成库文件。 一个库往往是许多算法程序的集合。在Linux中，库文件分成静态库和共享库两种。静态库以.a作为后缀名，共享库以.so结尾。所有库都是一些函数打包后的集合，差别在于静态库每次被调用时都会生成一个副本，而共享库只有一个副本，更节省空间。 生成静态库的cmake命令： 12# 添加一个库,hello是库名，libHello.cpp是源文件。add_library(hello libHello.cpp) 这行命令会生成一个libhello.a文件。 生成动态库的cmake命令： 12# 添加一个共享库，SHARED表示“共享”，hello_shared是库名，libHello.cpp是源文件。add_library(hello_shared SHARED libHello.cpp) 这行命令会生成libhello_shared.so文件。 库文件是一个压缩包，里面有编译好的二进制函数。但是，如果仅有.a和.so文件，我们并不知道里面的函数是什么，调用的形式又是怎么样的，为了使用这个库，我们需要提供一个头文件。 因此，对于库的使用者来说，只要拿到了头文件和库文件，就可以调用这个库。如果可执行程序想调用库文件中的函数，则它需要参考该库提供的头文件（即在源.cpp文件中#include &lt;库的头文件&gt;），以明白调用的格式。同时，要把可执行程序链接到库文件上。 相关的cmake命令如下： 12345# 使用useHello.cpp源文件生成可执行文件useHello# useHello.cpp第一行是#include&lt;hello_shared共享库的头文件&gt;add_executable(useHello useHello.cpp) # 将可执行文件useHello链接到库hello_shared上target_link_libraries(useHello hello_shared) CMakeLists.txt文件用于告诉cmake在这个目录下做什么事情。CMakeList.txt文件的内容需要遵守cmake的语法。 1234567# 声明要求最低的cmake版本cmake_minimum_required(VERSION 3.0)# 声明一个cmake工程，工程名demoproject(demo)# 添加一个可执行程序# 语法：add_executable(程序名 源代码文件)add_executable(hello hello.cpp)"},{"title":"如何在ROS功能包中引用其它ROS功能包","path":"//posts/2023/08/blog-post-2/","content":"如何在一个ROS功能包中引用其它ROS功能包？假设被引用的ROS包名称为third_pkg。 首先在CMakeList.txt中修改如下内容： 123find_package(catkin REQUIRED COMPONENTS\tthird_pkg) 接着在package.xml中添加如下内容： 1234&lt;build_depend&gt;third_pkg&lt;/build_depend&gt;&lt;build_export_depend&gt;third_pkg&lt;/build_export_depend&gt;&lt;exec_depend&gt;third_pkg&lt;/exec_depend&gt;"},{"title":"NeRF原理剖析","path":"//posts/2023/08/blog-post-1/","content":"NeRF认为场景是一团发光粒子云（或者说烟雾，fog）。 体渲染将区间$[t_n,t_f]$划分为$N$个长度相同的bins（箱子），然后在每个箱子内按照均匀分布进行采样，用数学语言描述为： t_i\\sim\\mathcal{U}\\bigg[t_n+\\frac{i-1}{N}(t_f-t_n),t_n+\\frac{i}{N}(t_f-t_n)\\bigg] C(t_{N+1})=\\sum_{i=1}^N\\mathcal{T}_i\\cdot(1-\\exp\\left(-\\sigma_i\\delta_i\\right))\\cdot\\mathbf{c}_i,\\quad\\text{其中}\\quad\\mathcal{T}_i=\\exp\\left(-\\sum_{j=1}^{i-1}\\sigma_j\\delta_j\\right)这里的$\\delta_i=t_{i+1}-t_i$是相邻采样点之间的距离。 最后，不使用包含体密度的项来表示这些表达式，使用alpha分解得到的权重$\\alpha_{i}\\equiv1-\\exp\\left(-\\sigma_{i}\\delta_{i}\\right)$将公式化简为： C(t_{N+1})=\\sum_{i=1}^N\\mathcal{T}_i\\cdot\\alpha_i\\cdot\\mathbf{c}_i,\\quad\\text{其中}\\quad\\mathcal{T}_i=\\prod_{j=1}^{i-1}(1-\\alpha_j)分层采样策略 \\hat{C}_c(\\mathbf{r})=\\sum_{i=1}^{N_c}w_ic_i,\\quad w_i=\\mathcal{T}_i(1-\\exp(-\\sigma_i\\delta_i))将这些权重归一化为$\\hat{w_{i}}=w_{i}\\Big/\\sum_{j=1}^{N_{c}}w_{j}$得到一个分段常数概率密度函数，在这个分布上使用逆变换采样得到第二组$N_f$个采样点位置。"}]